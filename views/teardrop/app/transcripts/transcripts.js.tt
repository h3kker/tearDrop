'use strict';

angular.module('TearDrop.transcripts', ['ngRoute', 'ui.bootstrap', 'ui.grid', 'ui.grid.pagination'])

.config(['$routeProvider', function($routeProvider) {
  $routeProvider.when('/transcripts', {
    templateUrl: '[% config.base_uri %]/app/transcripts/transcripts.html',
    controller: 'TranscriptsCtrl'
  });
  $routeProvider.when('/genes/:id', {
    templateUrl: '[% config.base_uri %]/app/transcripts/gene_details.html',
    controller: 'GenesDetailCtrl'
  });
  $routeProvider.when('/transcripts/:id', {
    templateUrl: '[% config.base_uri %]/app/transcripts/transcript_details.html',
    controller: 'TranscriptsDetailCtrl'
  });
}])
.controller('TranscriptsCtrl', ['$rootScope', '$scope', '$http', function($rootScope, $scope, $http) {
  $rootScope.transcripts={
    'pagingOptions': {
      'page': 1,
      'pagesize': 50,
    }
  };
  $scope.gridOptions={
    showFooter: true,
    minRowsToShow: 20,
    rowsPerPage: $rootScope.transcripts.pagingOptions.pagesize,
    columnDefs: [
      { name: 'Transcript', field: 'id' },
      { name: 'Gene', field: 'gene.id', cellTemplate: '<div class="ui-grid-cell-contents"><a href="#/genes/{{COL_FIELD}}">{{COL_FIELD CUSTOM_FILTERS}}</a></div>' },
      { name: 'Name', field: 'name' },
      { name: 'Organism', field: 'organism.scientific_name' },
      { name: 'Best Homolog', field: 'best_homolog' },
    ],
  };

  $scope.gridOptions.onRegisterApi = function(gridApi) {
    $scope.gridApi = gridApi;
  };

  $scope.$watch('transcripts.pagingOptions', function (newVal, oldVal) {
    if (newVal !== oldVal && newVal.page !== oldVal.page) {
      $scope.refresh();
    }
  }, true);
  $scope.refresh = function() {
    $http.get('[% config.base_uri %]/api/transcripts', { 'params': $rootScope.transcripts.pagingOptions }).success(
      function(res) {
        $rootScope.transcripts.pagingOptions.total_items = res.total_items;
        $scope.gridOptions.data = res.data;
      }
    ).error($rootScope.errHandler);
  }
  $scope.refresh();
}])
.controller('TranscriptsDetailCtrl', ['$rootScope', '$routeParams', '$scope', '$http', 'growl', function($rootScope, $routeParams, $scope, $http) {
  $scope.refresh = function() {
    $scope.transcript=null;
    $http.get('[% config.base_uri %]/api/transcripts/'+$routeParams.id).success(function(data) {
      $scope.transcript=data;
    }).error($rootScope.errHandler);
  };
  $scope.refresh();
}])
.controller('GenesDetailCtrl', ['$rootScope', '$routeParams', '$scope', '$http', 'uiGridConstants', '$timeout', 'Gene', function($rootScope, $routeParams, $scope, $http, uiGridConstants, $timeout, Gene) {
  $scope.selectedDbs=[];
  $scope.selectedTags=[];
  $scope.geneDbSources = angular.copy($rootScope.dbSources);
  $scope.runBlast = function(selectedDbs) {
    console.log(selectedDbs);
    angular.forEach(selectedDbs, function(db) {
      $http.get('[% config.base_uri %]/api/genes/'+$scope.gene.id+'/run_blast', {
        'params': { database: db.name }
      }).success(function(d) {
        db.status='started';
        $rootScope.updateQueueStatus();
        var queryJobStatus = function(pid) {
          $timeout(function() {
            $http.get('[% config.base_uri %]/api/worker/status/'+pid).success(function(jobData) {
              angular.forEach($scope.geneDbSources, function(dbs) {
                if (dbs.name==db.name) {
                  dbs.status=jobData.status;
                }
              });
              if (jobData.status != 'done' && jobData.status != 'failed') {
                queryJobStatus(pid);
              }
              else if (jobData.status == 'done') {
                $scope.loadHomologs(true);
              }
            });
          }, 5000);
        }
        if (d.pid) {
          queryJobStatus(d.pid);
        }
      }).error($rootScope.errHandler);
    });
  }
  $scope.blastGridOptions={
    showFooter: true,
    enableFiltering: true,
    rowsPerPage: 10,
    minRowsToShow: 50,
    columnDefs: [
      { name: 'Transcript', field: 'transcript_id', width: '10%' },
      { name: 'DB', field: 'db_source', width: '10%' },
      { name: 'Hit', field: 'stitle', width: '40%' },
      { name: 'e-value', field: 'evalue', width: '10%', sort: { priority: 0, direction: uiGridConstants.ASC }, filter: { condition: uiGridConstants.filter.LESS_THAN } },
      { name: 'Match Length', field: 'length', width: '10%' },
      { name: 'positive %', field: 'ppos', width: '10%', filter: { condition: uiGridConstants.filter.GREATER_THAN } },
      { name: 'identical %', field: 'pident', width: '10%', sort: { priority: 1, direction: uiGridConstants.DESC }, filter: { condition: uiGridConstants.filter.GREATER_THAN } },
    ],
    onRegisterApi: function(gridApi) {
      gridApi.selection.on.rowSelectionChanged($scope,function(row){
        $scope.gene.best_homolog=row.entity.source_sequence_id;
        $scope.gene.description=row.entity.stitle;
        $scope.saveGene();
      });
    },
  };
  $scope.addTags = function(selectedTags) {
    $scope.gene.tags=$scope.gene.tags.concat(selectedTags);
    $scope.saveGene();
  }
  $scope.removeTag = function(tag) {
    $scope.gene.tags=$scope.gene.tags.filter(function(t) {
      return t.tag!=tag.tag;
    });
    $scope.saveGene();
  }
  $scope.setRating = function(val) {
    $scope.gene.rating=val;
    $scope.gene.reviewed=true;
    $scope.saveGene();
  }
  $scope.saveGene = function() {
    $scope.gene.$save(function(g) {
      g.prepare();
    }, $rootScope.errHandler);
  };
  $scope.deGridOptions={
    showFooter: true,
    rowsPerPage: 10,
    multiSelect: false,
    enableRowSelection: true,
    columnDefs: [
      { name: 'DE Run', field: 'de_run.description' },
      { name: 'Base Cond', field: 'contrast.base_condition.name', },
      { name: 'Contrast Cond', field: 'contrast.contrast_condition.name', },
      { name: 'Base Mean', field: 'base_mean', aggregationType: uiGridConstants.aggregationTypes.avg },
      { name: 'p-value', field: 'pvalue', aggregationType: uiGridConstants.aggregationTypes.min },
      { name: 'Adjusted p-value', field: 'adjp', aggregationType: uiGridConstants.aggregationTypes.min },
      { name: 'log2 Foldchange', field: 'log2_foldchange', aggregationType: uiGridConstants.aggregationTypes.max },
    ],
  };
  $scope.alignments={};
  $scope.getArg = function(arg) { return function(d) { return d[1][arg] } };
  $scope.loadAlignments = function(reload) {
    console.log('loadAlignments '+$scope.alignments.viewTranscript.id);
    if ($scope.alignments.viewTranscript==null) return;
    if (reload || $scope.alignments[$scope.alignments.viewTranscript.id]==null) {
      $scope.alignments[$scope.alignments.viewTranscript.id]=[];
      $http.get('[% config.base_uri %]/api/transcripts/'+$scope.alignments.viewTranscript.id+'/pileup').success(function(data) {
        $scope.alignments[$scope.alignments.viewTranscript.id]=data;
      }).error($rootScope.errHandler);
    }
  }
  $scope.loadHomologs = function(reload) {
    if (reload || $scope.gene.blast_results==null) {
      $http.get('[% config.base_uri %]/api/genes/'+$scope.gene.id+'/blast_runs').success(function(data) {
        $scope.gene.blast_runs=data;
        $scope.setBlastRuns();
      });
      $http.get('[% config.base_uri %]/api/genes/'+$scope.gene.id+'/blast_results').success(function(data) {
        $scope.gene.blast_results=data;
        angular.forEach($scope.gene.blast_results, function(br) {
          ['evalue', 'length', 'ppos', 'pident'].forEach(function(f) {
            br[f]=parseFloat(br[f]);
          });
        });
        $scope.blastGridOptions.data=$scope.gene.blast_results;
      }).error($rootScope.errHandler);
    }
  }
  $scope.refresh = function() {
    $scope.gene = Gene.get({id: $routeParams.id}, function(data) {
      $scope.gene.prepare();
      if ($scope.viewTranscript==null) {
        $scope.alignments.viewTranscript=$scope.gene.transcripts[0];
      }
      $scope.setBlastRuns();
      $scope.deGridOptions.data=$scope.gene.de_results;
    }, $rootScope.errHandler);
  }
  $scope.refresh();

  $scope.setBlastRuns = function() {
    angular.forEach($scope.geneDbSources, function(db) {
      db.status='not run';
    });
    angular.forEach($scope.gene.blast_runs, function(br) {
      angular.forEach($scope.geneDbSources, function(db) {
        if (db.status == null) {
          db.status='not run';
        }
        if (db.name==br.db_source.name) {
          db.status='done - '+br.hits+' hits on '+br.matched_transcripts+'/'+$scope.gene.transcripts.length+' transcripts';
          db.hits=br.hits;
          db.matched_transcripts=br.matched_transcripts;
        }
      });
    });
  }
}]);
