angular.module('tearDropDirectives', []).
  directive('blastGrid', function(uiGridConstants, $rootScope, $http, $timeout) {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: '[% config.base_uri %]/app/partials/homologies.html',
      scope: {
        gridOptions: '=',
        ngModel: '=',
      },
      link: function($scope, element, attr) {
        $scope.tags=$rootScope.tags;
        $scope.selectedDbs=[];
        $scope.dbSources=angular.copy($rootScope.dbSources);
        angular.extend($scope.gridOptions, {
          showFooter: true,
          enableFiltering: true,
          minRowsToShow: 50,
          multiSelect: false,
          columnDefs: [
            { name: 'Transcript', field: 'transcript_id', width: '10%', filter: { condition: uiGridConstants.filter.CONTAINS } },
            { name: 'DB', field: 'db_source', width: '10%', filter: { condition: uiGridConstants.filter.CONTAINS }},
            { name: 'Hit', field: 'stitle', width: '40%', filter: { condition: uiGridConstants.filter.CONTAINS }},
            { name: 'e-value', field: 'evalue', width: '10%', sort: { priority: 0, direction: uiGridConstants.ASC }, filter: { condition: uiGridConstants.filter.LESS_THAN } },
            { name: 'Match Length', field: 'length', width: '10%', filter: { condition: uiGridConstants.filter.GREATER_THAN } },
            { name: 'positive %', field: 'ppos', width: '10%', filter: { condition: uiGridConstants.filter.GREATER_THAN } },
            { name: 'identical %', field: 'pident', width: '10%', sort: { priority: 1, direction: uiGridConstants.DESC }, filter: { condition: uiGridConstants.filter.GREATER_THAN } },
          ],
        });
        $scope.gridOptions.onRegisterApi = function(gridApi) {
          gridApi.selection.on.rowSelectionChanged($scope,function(row){
            $scope.ngModel.best_homolog=row.entity.source_sequence_id;
            $scope.ngModel.name=row.entity.stitle;
            $scope.ngModel.save();
          });
        };
        $scope.runBlast = function(selectedDbs) {
          console.log(selectedDbs);
          angular.forEach(selectedDbs, function(db) {
            $http.get('[% config.base_uri %]/api/'+$scope.ngModel.type+'s/'+$scope.ngModel.id+'/run_blast', {
              'params': { database: db.name }
            }).success(function(d) {
              db.status='started';
              $rootScope.updateQueueStatus();
              var queryJobStatus = function(pid) {
                console.log('here');
                $timeout(function() {
                  $http.get('[% config.base_uri %]/api/worker/status/'+pid).success(function(jobData) {
                    angular.forEach($scope.dbSources, function(dbs) {
                      if (dbs.name==db.name) {
                        dbs.status=jobData.status;
                      }
                    });
                    if (jobData.status != 'done' && jobData.status != 'failed') {
                      queryJobStatus(pid);
                    }
                    else if (jobData.status == 'done') {
                      $scope.loadHomologs(true);
                    }
                  });
                }, 5000);
              }
              if (d.id) {
                queryJobStatus(d.id);
              }
            }).error($rootScope.errHandler);
          });
        }

        $scope.loadHomologs = function(reload) {
          if (reload || $scope.ngModel.blast_results==null) {
            $scope.ngModel.loadBlastRuns($scope.setBlastRuns);
            $scope.ngModel.loadBlastResults(function(data) {
              $scope.gridOptions.data=$scope.ngModel.blast_results;
            });
          }
        }

        $scope.setBlastRuns = function() {
          angular.forEach($scope.dbSources, function(db) {
            if (db.status==null || db.status=='') db.status='not run';
          });
          angular.forEach($scope.ngModel.blast_runs, function(br) {
            angular.forEach($scope.dbSources, function(db) {
              if (db.status == null) {
                db.status='not run';
              }
              if (db.name==br.db_source.name) {
                if ($scope.ngModel.transcripts != null) 
                  db.status='done - '+br.hits+' hits on '+br.matched_transcripts+'/'+$scope.ngModel.transcripts.length+' transcripts';
                else 
                  db.status='done - '+br.hits+' hits';
                db.hits=br.hits;
                db.matched_transcripts=br.matched_transcripts;
              }
            });
          });
        }
        $scope.$watch('ngModel.id', function(newVal, oldVal) {
          if (newVal != null && newVal != oldVal) $scope.loadHomologs();
        });
      },
         
    }
  }).
  directive('pagedGrid', function(uiGridConstants, $timeout, $location, $rootScope) {
    return {
      restrict: 'E',
      replace: true,
      template: '<div><button ng-click="param.getFasta()" class="btn btn-xs">Get FASTA file</button><pagination items-per-page="param.pagingOptions.pagesize" total-items="param.pagingOptions.total_items" ng-model="param.pagingOptions.page" max-size="10" class="pagination-sm" boundary-links="true" rotate="false"></pagination><div ui-grid="gridOptions" class="grid"></div></div>',
      scope: {
        gridOptions: '=',
        refresh: '=',
        param: '=',
      },
      link: function($scope, element, attr) {
        if ($scope.param.selectedTags==null) $scope.param.selectedTags=[];
        if ($scope.param.sort==null) $scope.param.sort=[];
        if ($scope.param.filters==null) $scope.param.filters={};
        angular.extend($scope.param, {
          addTag: function(newTag) {
            if (!$scope.param.selectedTags.some(function(t) { return t.tag==newTag.tag })) {
              $scope.param.selectedTags.push(newTag);
              $scope.param.doRefresh();
            }
          },
          removeTag: function(oldTag) {
            $scope.param.selectedTags=$scope.param.selectedTags.filter(function(t) {
              return t.tag!==oldTag.tag;
            });
            $scope.param.doRefresh();
          },
        });
        angular.forEach($location.search(), function(v,k) {
          if (k==='page' || k==='pagesize') {
            $scope.param.pagingOptions[k]=v;
          }
          if (k.match(/^sort-/)) {
            var s=k.split('-');
            $scope.param.sort[s[1]]={ field: s[2], direction: v };
          }
          if (k.match(/^filter\./)) {
            var s=k.split('.');
            if (s[1]==='tags') {
              angular.forEach(v, function(wanted) {
                angular.forEach($rootScope.tags, function(tag) {
                  if (tag.tag===wanted) {
                    if (!$scope.param.selectedTags.some(function(t) { return t.tag==wanted })) {
                      $scope.param.selectedTags.push(tag);
                    }
                  }
                });
              });
            }
            else {
              $scope.param.filters[s[1]]=v;
            }
          }
        });
        angular.extend($scope.gridOptions, {
          enableFiltering: true,
          useExternalFiltering: true,
          useExternalSorting: true,
          rowsPerPage: $scope.param.pagingOptions.pagesize,
        });
        angular.forEach($scope.gridOptions.columnDefs, function(col) {
          if ($scope.param.filters != null && $scope.param.filters[col.field]) {
            col.filter={ term: $scope.param.filters[col.field] };
          }
          angular.forEach($scope.param.sort, function(v,k) {
            if (v.field==col.field) {
              col.sort={ priority: k, direction: v.direction=='asc' ? uiGridConstants.ASC : uiGridConstants.DESC };
            }
          });
        });
        $scope.gridOptions.onRegisterApi = function(gridApi) {
          gridApi.core.on.sortChanged($scope, function(grid, sortColumns) {
            $scope.param.sort=[];
            angular.forEach(sortColumns, function(col) {
              $scope.param.sort.push({
                field: col.field,
                direction: col.sort.direction==uiGridConstants.DESC ? 'desc' : 'asc',
              });
            });
            $scope.param.doRefresh();
          });
          gridApi.core.on.filterChanged($scope, function() {
            var grid = this.grid;
            $scope.param.filters={};
            angular.forEach(grid.columns, function(col) {
              angular.forEach(col.filters, function(f) {
                if (f.term !== null && f.term !== '') {
                  $scope.param.filters[col.field]=f.term;
                }
              });
            });
            if ($scope.loading !== null) $timeout.cancel($scope.loading);
            $scope.loading=$timeout(function() {
              $scope.param.doRefresh();
            }, 250);
          });

        }
        $scope.param.generateUrlParams = function(p) {
          if (p==null) p={};
          if ($scope.param.selectedTags.length>0) {
            p['filter.tags']=[];
            angular.forEach($scope.param.selectedTags, function(v) {
              p['filter.tags'].push(v.tag);
            });
          }
          angular.forEach($scope.param.filters, function(v,k) {
            p['filter.'+k]=v;
          });
          angular.forEach($scope.param.sort, function(v,k) {
            p['sort-'+k+'-'+v.field]=v.direction;
          });
          $location.search(p);
          return p;
        }
        $scope.param.doRefresh = function(force) {
          var p = $scope.param.generateUrlParams(angular.copy($scope.param.pagingOptions));
          if (force || $scope.curParams===null || !angular.equals(p, $scope.curParams)) {
            $scope.curParams=p;
            $scope.refresh(p);
          }
        }
        $scope.$watch('param.pagingOptions', function (newVal, oldVal) {
          if (newVal !== oldVal && newVal.page !== oldVal.page) {
            $scope.param.doRefresh();
          }
        }, true);
      },
    }
  }).
  directive('clickToEdit', function() {
    var editorTemplate = '<span class="click-to-edit">' +
      '<span ng-hide="view.editorEnabled">' +
        '{{value}} ' +
        '<button class="btn btn-xs" ng-click="enableEditor()"><span class="glyphicon glyphicon-pencil"></span></button>' +
      '</span>' +
      '<span ng-show="view.editorEnabled">' +
        '<input type="text" ng-model="view.editableValue">' +
        '<span class="btn-group">'+
         '<button class="btn btn-xs btn-success" ng-click="save()"><span class="glyphicon glyphicon-ok"></span></button>' +
         '<button class="btn btn-xs btn-warning" ng-click="disableEditor()"><span class="glyphicon glyphicon-remove"></span></button>' +
        '</span>'+
       '</span>' +
      '</span>';
    return {
      restrict: 'A',
      replace: true, 
      template: editorTemplate,
      require: '^ngModel',
      scope: {
        saveCallback: '=',
      },
      link: function($scope, element, attr, ngModelCtrl) {
        ngModelCtrl.$formatters.push(function(modelValue) {
          return modelValue;
        });
        ngModelCtrl.$render = function() {
          $scope.value=ngModelCtrl.$viewValue;
        }
        ngModelCtrl.$parsers.push(function(viewValue) {
          return viewValue;
        });
        $scope.view = {
          editableValue: $scope.value,
          editorEnabled: false,
        };
        $scope.$watch('value', function() {
          if (ngModelCtrl.$viewValue !== $scope.value) {
            ngModelCtrl.$setViewValue($scope.value);
            $scope.saveCallback();
          }
        });
        $scope.enableEditor=function() {
          $scope.view.editorEnabled = true;
          $scope.view.editableValue = $scope.value;
        }
        $scope.disableEditor=function() {
          $scope.view.editorEnabled = false;
        }
        $scope.save = function() {
          $scope.value = $scope.view.editableValue;
          $scope.view.editorEnabled = false;
        }
      },
    };
  })
  .directive('organismCounts', function() {
    return {
      restrict: 'E',
      replace: true,
      template: '<div>'+
         '<span ng-repeat="org in ngModel | orderBy:\'count\'">{{org.scientific_name}}: {{org.count}}</span>'+
        '</div>',
      scope: {
        ngModel: '=',
      },
    }
  })
  .directive('prettyFoldchange', function() {
    return {
      restrict: 'E',
      template: '<span ng-style="fcStyle">{{ngModel.log2_foldchange}}</span>',
      transclude: true,
      scope: {
        ngModel: '=',
      },
      link: function($scope, element, attr) {
        var hue=Math.max(120, Math.min(360, 240-$scope.ngModel.log2_foldchange/5*120));
        var alpha=Math.max(0.5, Math.min(1, -1*Math.log10($scope.ngModel.adjp)/2));
        $scope.fcStyle={
          'color': 'hsla('+hue+',60%,70%,'+alpha+')',
        };
      },
    }
  })
  .directive('genomeAlignments', function($http, $rootScope) {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: '[% config.base_uri %]/app/partials/genome_alignments.html',
      scope: {
        mappings: '=',
      },
      compile: function(element, attr) {
        return {
          pre: function($scope, element, attr) {
            $scope.coverageChartConfig = {
              options: {
                "chart": { "type": "area", zoomType: 'x' },
                "plotOptions": { 
                  "series": { "stacking":"normal", marker: { enabled: false } }, 
                },
              },
              series: [],
              title: { text: '' },
              loading: $scope.alignmentLoading,
              xAxis: { min: 0, },
              yAxis: [
                { title: { text: 'Coverage' }, },
                { title: { text: 'Mismatch Rate' }, opposite: true, min: 0 }
              ],
              size: { width: 800, height: 500, }
            };
          },
          post: function($scope, element, attr) {
            $scope.loadAnnotations = function(map, reload) {
              if (reload || map.annotations==null) {
                map.annotations=[];
                $http.get('[% config.base_uri %]/api/genome_mappings/'+map.genome_mapping_id+'/annotations', {params: {tid: map.tid, tstart: map.tstart, tend: map.tend}}).success(function(data) {
                    map.annotations=data;
                }).error($rootScope.errHandler);
              }
            }

            $scope.loadGenomeAlignments = function(map, reload) {
              if (map==null) return;
              if (reload || map.alignment==null) {
                map.alignment=[];
                $scope.alignmentLoading=false;
                $http.get('[% config.base_uri %]/api/genome_mappings/'+map.genome_mapping_id+'/pileup', {params: {tid: map.tid, tstart: map.tstart, tend: map.tend}}).success(function(data) {
                  $scope.alignmentLoading=true;
                  angular.forEach(data.mismatch, function(s, sample) {
                    s.type='bar';
                    s.name=s.name+' Mis';
                    //s.yAxis=1;
                    angular.forEach(s.data, function(v,k) {
                      /*
                      s.data[k]=data.coverage[sample].data[k]>0 ? 
                        s.data[k]/data.coverage[sample].data[k] : null;
                      */
                      s.data[k]=s.data[k]>0 ? s.data[k] : null;
                    });
                    $scope.coverageChartConfig.series.push(s);
                  });
//                  angular.forEach(data.coverage, function(s, sample) {
//                    s.type='area';
//                    angular.forEach(s.data, function(v,k) {
//                      if (s.data[k]==0) s.data[k]=null;
//                    });
//                    $scope.coverageChartConfig.series.push(s);
//                  });
                  angular.forEach(data.coverage_plus, function(s, sample) {
                    s.type='line';
                    s.name=s.name+'+';
                    angular.forEach(s.data, function(v,k) {
                      //s.data[k] = s.data[k]>0 ? s.data[k] : null;
                      s.data[k] = s.data[k]+data.coverage_minus[sample].data[k];
                    });
                    $scope.coverageChartConfig.series.push(s);
                  });
                  /*
                  angular.forEach(data.coverage_minus, function(s, sample) {
                    s.type='line';
                    s.name=s.name+'-';
                    angular.forEach(s.data, function(v,k) {
                      s.data[k] = s.data[k]>0 ? s.data[k]*-1 : null;
                    });
                    $scope.coverageChartConfig.series.push(s);
                  });
                  */
                }).error($rootScope.errHandler);
              }
            }
            $scope.$watchCollection('mappings', function(newMaps) {
              angular.forEach($scope.mappings, $scope.loadAnnotations);
            });
          },
        };
      },
    }
  })
  .directive('transcriptAlignment', function($http, $rootScope) {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: '[% config.base_uri %]/app/partials/transcript_alignment.html',
      compile: function(element, attr) {
        return {
          pre: function($scope, element, attr) {
            $scope.coverageChartConfig = {
              options: {
                "chart": { "type": "area", zoomType: 'x' },
                "plotOptions": { 
                  "series": { "stacking":"normal" }, 
                },
              },
              series: [],
              title: { text: '' },
              loading: $scope.transcript.alignmentLoading,
              xAxis: { min: 0, },
              yAxis: [
                { title: { text: 'Coverage' }, },
                { title: { text: 'Mismatch Rate' }, opposite: true, max: 1, min: 0 }
              ],
              size: { width: 800, height: 500, }
            };
          },
          post: function($scope, element, attr) {
            $scope.$watch('transcript.alignment', function(newValue) {
              if (newValue != null) {
                angular.forEach(newValue.mismatch, function(s, sample) {
                  s.type='line';
                  s.yAxis=1;
                  angular.forEach(s.data, function(v,k) {
                    s.data[k]=newValue.coverage[sample].data[k]>0 ? 
                      s.data[k]/newValue.coverage[sample].data[k] : null;
                  });
                  $scope.coverageChartConfig.series.push(s);
                });
                angular.forEach(newValue.coverage, function(s, sample) {
                  s.type='area';
                  angular.forEach(s.data, function(v,k) {
                    if (s.data[k]==0) s.data[k]=null;
                  });
                  $scope.coverageChartConfig.series.push(s);
                });
              }
            });
            $scope.$watch('transcript.nsequence', function(v) {
              if (v!=null) $scope.coverageChartConfig.xAxis.max=v.length;
            });
            $scope.$watch('transcript.alignmentLoading', function(v) {
              $scope.coverageChartConfig.loading=v;
            });
          },

        };
      },
    }
  })
  .directive('reviewedDescription', function() {
   return {
     restrict: 'E',
     replace: true,
     template: '<div>'+
       '<span ng-show="ngModel.name">{{ngModel.name}}</span>'+
       '<span ng-show="!ngModel.name && ngModel.reviewed"><em>Unknown</em></span>'+
       '<span ng-show="ngModel.reviewed" class="glyphicon glyphicon-ok-sign"></span>'+
       '<span ng-hide="ngModel.reviewed" class="glyphicon glyphicon-question-sign"></span>'+
      '</div>',
     scope: {
      ngModel: '=',
     },
   }
 });

